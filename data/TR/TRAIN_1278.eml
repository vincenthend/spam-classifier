{'body': 'On 05/12/2010 07:03 PM, Stefan Monnier wrote:\n>> The 64-bit vs 32-bit argument is multi-faceted.  It gets much deeper than\n>> just addressing more than 3GB of RAM:\n>> * twice the transfer width on the bus\n> \n> Nope, no difference on the bus.   Most accesses will be\n> cache-line-sized anyway at that level.\n\nYou\'re kidding, right? You can push twice the data, which means faster\nCPU to memory utilization for CPU intensive applications. Flash anyone?\n\n>> * no memory split issues\n> \n> For <=3GB systems, that makes no difference.  And as someone running\n> a bigmem kernel on a 4GB system, I can say that even for other systems,\n> it\'s not necessarily relevant.\n\nIt\'s very relevant. You must not have run into this issue much. 4:4\nkernel splits are the best you can do on a 32-bit system, but it comes\nat a performance cost. Splitting and performance are never an issue on\n64-bit until you\'ve reache 17 EB of RAM.\n\n>> * increased virtual address space\n> \n> Right.  Unlikely he\'ll ever notice it.\n\nWhether he will or won\'t isn\'t the issue. I\'m not discussing use cases,\nI\'m discussing the facts on why 64-bit is superior to 32-bit.\n\n>> * more breathing room for mmap()\'d files\n> \n> Again, unlikely he\'ll ever notice it (otherwise he wouldn\'t have asked).\n\nSee above.\n\n>> * deeper nested system calls with increased stability\n> \n> I see no evidence of increased stability and have no idea what you want\n> to say with "deeper nested system calls".\n\nI\'ll give you an example. Use XFS on LVM, and export the mount over NFS.\nThe nested system calls in this scenario will cause a kernel oops on any\n4K 32-bit kernel nearly every time (the default for Debian GNU/Linux,\nFedora, Ubuntu, openSUSE, etc). On a 64-bit kernel, because you have the\nability to make deeper nested system calls, you have stability in your\ninfrastructure. Something that couldn\'t be achieved with a 32-bit kernel.\n\n>> * certain applications and operations will execute faster\n> \n> Yup.  And others will be slower since you\'ll have to move around more\n> data (up to twice as much if your data is made up mostly of pointers),\n> which means that the apparent cache and RAM size will end up\n> being reduced.\n\nThe same would be said for a 32-bit application implemented the same\nway. Poor software development is hardly an argument against choosing a\nCPU architecture.\n\n>> If you have the hardware, you should definitely be running a 64-bit\n>> operating system, even if you don\'t have 4GB+ of RAM.\n> \n> If you have to ask, you probably won\'t notice any difference\n> either way.\n\nTo each their own. I for one want to get my money out of my hardware. If\nyou don\'t want a 64-bit system, then why did you pay for it?\n\n-- \n. O .   O . O   . . O   O . .   . O .\n. . O   . O O   O . O   . O O   . . O\nO O O   . O .   . O O   O O .   O O O\n\n', 'subject': 'Re: What to choose for Core i5 64 bits?'}