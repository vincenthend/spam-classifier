{'body': "\r\nOn Apr 16, 2010, at 3:53 PM, Hamish Allan wrote:\r\n\r\n> Hi,\r\n>=20\r\n> I'm rather puzzled by some behaviour I'm seeing, as explained by the\r\n> comment in the following short category:\r\n>=20\r\n> @implementation NSPersistentStore (OTAdditions)\r\n> - (NSNumber *)autoincrementingNumberForKey:(NSString *)key\r\n> {\r\n>    NSNumber *number;\r\n>    @synchronized(self)\r\n>    {\r\n>        NSMutableDictionary *metadata =3D [[self metadata] =\r\nmutableCopy];\r\n>=20\r\n>        // need to copy and autorelease the number because the original\r\n>        // does not remain valid outside of the @synchronized block =\r\n(why?!)\r\n>        number =3D [[[metadata objectForKey:key] copy] autorelease];\r\n>=20\r\n>        if (!number)\r\n>            number =3D [NSNumber numberWithUnsignedLongLong:1];\r\n>        [metadata setValue:[NSNumber\r\n> numberWithUnsignedLongLong:([number unsignedLongLongValue] + 1)]\r\n> forKey:key];\r\n>        [self setMetadata:metadata];\r\n>    }\r\n>    return number;\r\n> }\r\n> @end\r\n>=20\r\n> The behaviour I'm seeing is as though the NSNumber returned by\r\n> [metadata objectForKey:key] has been added to a special\r\n> mini-autorelease pool scoped by the @synchronized block, whereas the\r\n> autoreleased copy is added to the normal autorelease pool. At least, I\r\n> assume the NSNumber is being deallocated, but symbolic breakpoints on\r\n> -[NSNumber release] and -[NSNumber dealloc] remain in a pending state\r\n> so I haven't been able confirm that.\r\n>=20\r\n> Can anyone tell me what's going on here?\r\n\r\nNothing related to @synchronized. Your problem is that you are acquiring =\r\nan unretained pointer to an object, then doing something that releases =\r\nthe object behind your back.\r\n\r\n    number =3D [metadata objectForKey:key];\r\n\r\n`number` now points to some object. Importantly, -objectForKey: just =\r\nhands back the pointer, without doing the [[result retain] autorelease] =\r\ndance. It's possible that the only thing that retained `number` is the =\r\n`metadata` dictionary.\r\n\r\n    [metadata setValue:something forKey:key];\r\n\r\nNow `metadata` has released `number`. It may be dead.\r\n\r\nYou need to be careful with -objectForKey: and -objectAtIndex: while you =\r\nare mutating the container. Those methods avoid autorelease for =\r\nperformance, but (as you found) it's also less safe.\r\n\r\nYour solution of copy+autorelease is correct. retain+autorelease might =\r\nbe better.=20\r\n\r\n\r\n--=20\r\nGreg Parker     gparker@apple.com     Runtime Wrangler\r\n\r\n\r\n _______________________________________________\r\nDo not post admin requests to the list. They will be ignored.\r\nObjc-language mailing list      (Objc-language@lists.apple.com)\r\nHelp/Unsubscribe/Update your Subscription:\r\nhttp://lists.apple.com/mailman/options/objc-language/mlsubscriber.tech%40csmining.org\r\n\r\nThis email sent to mlsubscriber.tech@csmining.org\r\n\r\n", 'subject': 'Re: @synchronized scope strangeness'}