{'body': "\nOn Apr 16, 2010, at 3:53 PM, Hamish Allan wrote:\n\n> Hi,\n> \n> I'm rather puzzled by some behaviour I'm seeing, as explained by the\n> comment in the following short category:\n> \n> @implementation NSPersistentStore (OTAdditions)\n> - (NSNumber *)autoincrementingNumberForKey:(NSString *)key\n> {\n>    NSNumber *number;\n>    @synchronized(self)\n>    {\n>        NSMutableDictionary *metadata = [[self metadata] mutableCopy];\n> \n>        // need to copy and autorelease the number because the original\n>        // does not remain valid outside of the @synchronized block (why?!)\n>        number = [[[metadata objectForKey:key] copy] autorelease];\n> \n>        if (!number)\n>            number = [NSNumber numberWithUnsignedLongLong:1];\n>        [metadata setValue:[NSNumber\n> numberWithUnsignedLongLong:([number unsignedLongLongValue] + 1)]\n> forKey:key];\n>        [self setMetadata:metadata];\n>    }\n>    return number;\n> }\n> @end\n> \n> The behaviour I'm seeing is as though the NSNumber returned by\n> [metadata objectForKey:key] has been added to a special\n> mini-autorelease pool scoped by the @synchronized block, whereas the\n> autoreleased copy is added to the normal autorelease pool. At least, I\n> assume the NSNumber is being deallocated, but symbolic breakpoints on\n> -[NSNumber release] and -[NSNumber dealloc] remain in a pending state\n> so I haven't been able confirm that.\n> \n> Can anyone tell me what's going on here?\n\nNothing related to @synchronized. Your problem is that you are acquiring an unretained pointer to an object, then doing something that releases the object behind your back.\n\n    number = [metadata objectForKey:key];\n\n`number` now points to some object. Importantly, -objectForKey: just hands back the pointer, without doing the [[result retain] autorelease] dance. It's possible that the only thing that retained `number` is the `metadata` dictionary.\n\n    [metadata setValue:something forKey:key];\n\nNow `metadata` has released `number`. It may be dead.\n\nYou need to be careful with -objectForKey: and -objectAtIndex: while you are mutating the container. Those methods avoid autorelease for performance, but (as you found) it's also less safe.\n\nYour solution of copy+autorelease is correct. retain+autorelease might be better. \n\n\n-- \nGreg Parker     gparker@apple.com     Runtime Wrangler\n\n\n _______________________________________________\nDo not post admin requests to the list. They will be ignored.\nObjc-language mailing list      (Objc-language@lists.apple.com)\nHelp/Unsubscribe/Update your Subscription:\nhttp://lists.apple.com/mailman/options/objc-language/mlsubscriber.tech%40csmining.org\n\nThis email sent to mlsubscriber.tech@csmining.org\n\n", 'subject': 'Re: @synchronized scope strangeness'}