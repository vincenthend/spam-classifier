{'body': 'Adam Beberg writes:\n> On Tue, 3 Sep 2002, Kragen Sitaker wrote:\n> > Unix acquired nonblocking I/O in the form of select() about 23 years\n> > ago, and Solaris has had the particular aio_* calls we are discussing\n> > for many years.\n> \n> select() "scaling" is a joke at best, and I know you know that. poll() is\n> only a bit better.\n\nNot only do I know that, the post to which you were responding\nexplained that, with somewhat more detail than "a joke".  As you\nshould know, but evidently don\'t, poll() isn\'t even "a bit better" ---\nin fact, it\'s about an order of magnitude worse --- for dense file\ndescriptor sets, which is the normal case.  (Except on operating\nsystems where select() isn\'t a system call but a library routine that\ncalls poll().)\n\n> > Very few applications need the aio_* calls --- essentially only\n> > high-performance RDBMS servers even benefit from them at all, and\n> > most of those have been faking it fine for a while with multiple\n> > threads or processes.  This just provides a modicum of extra\n> > performance.\n> \n> Wrong, it makes a huge difference in even what I consider small programs.\n\nWhy don\'t you explain this in more detail?\n\n> > Although I don\'t have a copy of the spec handy, I think the aio_* APIs\n> > come from the POSIX spec IEEE Std 1003.1-1990, section 6.7.9, which is\n> > 13 years old, and which I think documented then-current practice.\n> > They might be even older than that.\n> \n> Yes, SGI has a patch to the linux kernel to implement the aio_ interfaces,\n> but it\'s still not built in, who knows when it will be. The point is it\'s\n> not portable in either case.\n\nYou originally said:\n\n  Could it be? After 20 years without this feature UNIX finally\n  catches up to Windows and has I/O that doesnt [sic] totally suck for\n  nontrivial apps? No way!\n\nThe point --- my point, the point I was discussing; please don\'t try\nto tell me you were trying to make a different point, because I don\'t\ncare --- is that you had no clue what you were talking about; Unix\nhasn\'t been without this feature, and in fact has had it since you\nwere in elementary school, and operating systems without it don\'t\n"totally suck for nontrivial apps".\n\nFor what it\'s worth, glibc has actually implemented the aio_* calls\nfor a while, just in a way that doesn\'t scale to large numbers of\nconcurrent I/O requests.  I find references to the glibc\nimplementation as far back as 1999 and glibc 2.1.1, and I could\nprobably find much earlier references if I had time:\nhttp://sources.redhat.com/ml/libc-hacker/1999-12/msg00070.html\n\n(more details at\nhttp://www.atnf.csiro.au/people/rgooch/linux/docs/io-events.html;\ndetails on the SGI patch are at\nhttp://oss.sgi.com/projects/kaio/faq.html)\n\n> > Unix has been multiprocess since 1969, and most Unix implementations\n> > have supported multithreading for a decade or more.\n> \n> And most UNIX is still kinda-sorta supporting the pthreads (POSIX)\n> interface, each in their own 7/8 implementation. You\'re safe if you\n> stick to the basics.\n\nYour original complaint was that Unix didn\'t do multithreading or\nmultiprogramming well.  Now that I\'ve pointed out how obviously\nidiotic that claim is, you\'ve amended your complaint: now, although\nindividual Unixes do these things well, you complain that their\nimplementations are not entirely conformant with the POSIX threads\nspecification.  Well, that\'s probably true, but I haven\'t written\npthreads programs in C much myself, so I can\'t confirm it from my own\nexperience.  But, even if it\'s true, it\'s not a very good reason to\nprefer Windows.\n\nI\'m sure you can provide examples of bugs in particular threading\nimplementations.  Spare us.  Just shut up.\n\n-- \n<kragen@pobox.com>       Kragen Sitaker     <http://www.pobox.com/~kragen/>\nEdsger Wybe Dijkstra died in August of 2002.  The world has lost a great\nman.  See http://advogato.org/person/raph/diary.html?start=252 and\nhttp://www.kode-fu.com/geek/2002_08_04_archive.shtml for details.\n\n', 'subject': 'Re: asynchronous I/O (was Re: Gasp!)'}