{'body': "\r\nOn Apr 30, 2010, at 9:09 PM, Matt Slot  wrote:\r\n\r\n> I'm iterating a movie frame by frame from a secondary thread. Rather  \r\n> than polling/spinning on QTVisualContextIsNewImageAvailable() for  \r\n> each frame, can I just CopyImageForTime() and let it block until the  \r\n> data is available? The alternative is to install a hook via  \r\n> QTVisualContextSetImageAvailableCallback() and trigger a semaphore,  \r\n> but blocking on the Copy call would be much more straightforward.\r\n\r\nIf you are using SetMovieTime and  \r\nQTVisualContextSetImageAvailableCallback  you can do everything on the  \r\nsecondary thread, after attaching the movie to this thread.\r\n\r\nIf you are playing the movie you need to play it on the main thread.\r\n\r\nNormally you would use a display link callback which calls the  \r\nQTVisualContextIsNewImageAvailable/QTVisualContextCopyImageForTime  \r\ncombo. Kind of smart polling.\r\n\r\nIf you don't want to poll you can use an ImageAvailableCallback and  \r\nand an input queue but I don't see much benefit from that. The  \r\noverhead of the display link is small and if you suspect that your  \r\nmovie has a higher frame rate than the display refresh time you can  \r\nalways call QTVisualContextIsNewImageAvailable multiple times until it  \r\nreturns false. Either you can keep up with the input or else you are  \r\ngoing to drop frames. The ImageAvailableCallback won't  help you there.\r\n\r\nJan E.\r\n\r\n _______________________________________________\r\nDo not post admin requests to the list. They will be ignored.\r\nQuickTime-API mailing list      (QuickTime-API@lists.apple.com)\r\nHelp/Unsubscribe/Update your Subscription:\r\nhttp://lists.apple.com/mailman/options/quicktime-api/mlsubscriber.tech%40csmining.org\r\n\r\nThis email sent to mlsubscriber.tech@csmining.org\r\n\r\n", 'subject': 'Re: Does QTVisualContextCopyImageForTime block?'}