{'body': 'From nobody Fri Sep  7 01:04:41 2018\nContent-Type: Text/Plain;\r\n  charset="utf-8"\nContent-Transfer-Encoding: quoted-printable\n\nOn Thursday 15 April 2010 13:56:00 Stephen Powell wrote:\r\n> On Wed, 14 Apr 2010 23:10:55 -0400 (EDT), Boyd Stephen Smith Jr. wrote:\r\n> > On Tuesday 13 April 2010 17:16:03 Stephen Powell wrote:\r\n> >> What I need to do is to have two structures overlay each other; so that\r\n> >>  they occupy the same storage.  To be specific, here is a structure\r\n> >> which describes the volume label for an OS-formatted disk:\r\n> >>\r\n> >> struct __attribute__ ((packed)) volume_label {\r\n> >>         char volkey[4];         /* volume key =3D volume label */\r\n> >> ...\r\n> >> };\r\n> >>\r\n> >> And here is a structure which describes the volume label for a\r\n> >>  CMS-formatted disk:\r\n> >>\r\n> >> struct __attribute__ ((packed)) cms_label {\r\n> >>         char label_id[4];       /* Label identifier */\r\n> >> ...\r\n> >> };\r\n> >\r\n> > union any_label {\r\n> > \tstruct volume_label vl;\r\n> > \tstruct cms_label    cl;\r\n> > };\r\n> >\r\n> >> Note that both structures have as their first member a character\r\n> >> variable of length 4.  In the case of the "volume_label" structure it =\r\nis\r\n> >> "volkey" and in the case of the "cms_label" structure it is "label_id"=\r\n=2E=20\r\n> >> If the value of this variable is "VOL1" (in EBCDIC) then it is the fir=\r\nst\r\n> >> structure which maps the storage.  If the value of this variable is\r\n> >> "CMS1" (in EBCDIC) then it is the second structure which maps the\r\n> >> storage.\r\n> >\r\n> > union any_label *label =3D /* Initialize somehow */;\r\n> > struct volume_label *maybe_vl =3D &label->vl;\r\n> > struct cms_label *maybe_cl =3D &label->cl;\r\n> >\r\n> > if (strncmp(maybe_vl->volkey, "VOL1", 4) =3D=3D 0) {\r\n> >     maybe_cl =3D NULL;\r\n> >     /* Use maybe_vl all you want, e.g. */\r\n> >     maybe_vl->security =3D 0xFF;\r\n> > } else if (strncmp(maybe_cl->label_id, "CMS1", 4) =3D=3D 0) {\r\n> >     maybe_vl =3D NULL;\r\n> >     /* Use maybe_cl all you want, e.g. */\r\n> >     printf("%lu\\n", (unsigned long) maybe_cl->disk_offset);\r\n> > } else {\r\n> >     assert(("Unrecognized disk!", 0));\r\n> > }\r\n>=20\r\n> Thanks, Boyd.  Your response comes the closest so far to what I\'m looking\r\n> for.  Based on what I know from other programming languages, I don\'t think\r\n> it\'s going to be necessary to explicitly declare a union.\r\n\r\nIt\'s possible, but I would generally do it for clarity.  I like using the=20\r\ntypes of variables/arguments as documentation, so I would store any data wh=\r\nere=20\r\nthe real type was unknown in the union.  Then access it though a "struct=20\r\ncms_label *" or "struct volume_label *" one I had determined the correct ty=\r\npe.\r\n\r\nSince C unions are not tagged, a C union is the same size as it\'s largest=20\r\nmember.  (NB: Not really sure how __attribute__((__packed__)) changes thing=\r\ns,=20\r\nif at all; it\'s possible you need it on the union to prevent padding from=20\r\nbeing added after the space occupied by the largest member.)\r\n\r\n> In short, I need to (a) declare "cms_label" as a based structure,\r\n\r\n(above; timmmed)\r\n\r\n> (b)\r\n> declare a pointer variable called  "cms_ptr" and associate it with the\r\n> "cms_label" structure,\r\n\r\nstruct cms_label *cms_ptr;\r\n\r\nInitialization optional, but recommended.\r\n\r\n> (c) make sure that the compiler does not attempt\r\n> to allocate any storage for the "cms_label" structure,\r\n\r\nSince you are declaring a pointer to a structure, and not declaring an obje=\r\nct=20\r\nwith type "struct cms_label", no space will be allocated for a cms_label.\r\n\r\n> (d) make sure that\r\n> the compiler automatically acquires storage for the "cms_ptr" pointer\r\n> variable itself,\r\n\r\nMake your declaration a definition and that\'ll be handled.  (Declarations a=\r\nnd=20\r\ndefinitions look very similar for non-function types; the code given above =\r\nis=20\r\nactually a definition if it is not within a struct/union type.)\r\n\r\n> (e) assign the address of the "volume_label" structure\r\n> to the "cms_ptr" pointer variable at an appropriate point in the code,\r\n> and\r\n\r\nstruct volume_label vl;\r\nstruct cms_label *cms_ptr;\r\n\r\n/* Load data into vl */\r\n/* Determine that the data is actually a cms_label */\r\ncms_ptr =3D (void *) &vl;\r\n\r\nOr, in your specific case, you should be able to do something like:\r\n\r\nstruct cms_label *cms_ptr =3D (void *) disk_specific->anchor->vlabel;\r\n\r\nSince you are already dealing with a "struct volume_label *", there\'s no ne=\r\ned=20\r\nfor the address-of operator (&).\r\n\r\n> (f) make references to the members of the cms_label structure.\r\n\r\ncms_ptr->label_id; /* Or any other member. */\r\n\r\n> How do I do this?  (Man, I wish I knew C!)\r\n\r\nExamples above good?  Please let me know if I can provide further assistanc=\r\ne.\r\n=2D-=20\r\nBoyd Stephen Smith Jr.           \t ,=3D ,-_-. =3D.\r\nbss@iguanasuicide.net            \t((_/)o o(\\_))\r\nICQ: 514984 YM/AIM: DaTwinkDaddy \t `-\'(. .)`-\'\r\nhttp://iguanasuicide.net/        \t     \\_/\r\n', 'subject': 'Re: C programming question'}