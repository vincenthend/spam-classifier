{'body': 'On Thursday 15 April 2010 13:56:00 Stephen Powell wrote:\n> On Wed, 14 Apr 2010 23:10:55 -0400 (EDT), Boyd Stephen Smith Jr. wrote:\n> > On Tuesday 13 April 2010 17:16:03 Stephen Powell wrote:\n> >> What I need to do is to have two structures overlay each other; so that\n> >>  they occupy the same storage.  To be specific, here is a structure\n> >> which describes the volume label for an OS-formatted disk:\n> >>\n> >> struct __attribute__ ((packed)) volume_label {\n> >>         char volkey[4];         /* volume key = volume label */\n> >> ...\n> >> };\n> >>\n> >> And here is a structure which describes the volume label for a\n> >>  CMS-formatted disk:\n> >>\n> >> struct __attribute__ ((packed)) cms_label {\n> >>         char label_id[4];       /* Label identifier */\n> >> ...\n> >> };\n> >\n> > union any_label {\n> > \tstruct volume_label vl;\n> > \tstruct cms_label    cl;\n> > };\n> >\n> >> Note that both structures have as their first member a character\n> >> variable of length 4.  In the case of the "volume_label" structure it is\n> >> "volkey" and in the case of the "cms_label" structure it is "label_id". \n> >> If the value of this variable is "VOL1" (in EBCDIC) then it is the first\n> >> structure which maps the storage.  If the value of this variable is\n> >> "CMS1" (in EBCDIC) then it is the second structure which maps the\n> >> storage.\n> >\n> > union any_label *label = /* Initialize somehow */;\n> > struct volume_label *maybe_vl = &label->vl;\n> > struct cms_label *maybe_cl = &label->cl;\n> >\n> > if (strncmp(maybe_vl->volkey, "VOL1", 4) == 0) {\n> >     maybe_cl = NULL;\n> >     /* Use maybe_vl all you want, e.g. */\n> >     maybe_vl->security = 0xFF;\n> > } else if (strncmp(maybe_cl->label_id, "CMS1", 4) == 0) {\n> >     maybe_vl = NULL;\n> >     /* Use maybe_cl all you want, e.g. */\n> >     printf("%lu\\n", (unsigned long) maybe_cl->disk_offset);\n> > } else {\n> >     assert(("Unrecognized disk!", 0));\n> > }\n> \n> Thanks, Boyd.  Your response comes the closest so far to what I\'m looking\n> for.  Based on what I know from other programming languages, I don\'t think\n> it\'s going to be necessary to explicitly declare a union.\n\nIt\'s possible, but I would generally do it for clarity.  I like using the \ntypes of variables/arguments as documentation, so I would store any data where \nthe real type was unknown in the union.  Then access it though a "struct \ncms_label *" or "struct volume_label *" one I had determined the correct type.\n\nSince C unions are not tagged, a C union is the same size as it\'s largest \nmember.  (NB: Not really sure how __attribute__((__packed__)) changes things, \nif at all; it\'s possible you need it on the union to prevent padding from \nbeing added after the space occupied by the largest member.)\n\n> In short, I need to (a) declare "cms_label" as a based structure,\n\n(above; timmmed)\n\n> (b)\n> declare a pointer variable called  "cms_ptr" and associate it with the\n> "cms_label" structure,\n\nstruct cms_label *cms_ptr;\n\nInitialization optional, but recommended.\n\n> (c) make sure that the compiler does not attempt\n> to allocate any storage for the "cms_label" structure,\n\nSince you are declaring a pointer to a structure, and not declaring an object \nwith type "struct cms_label", no space will be allocated for a cms_label.\n\n> (d) make sure that\n> the compiler automatically acquires storage for the "cms_ptr" pointer\n> variable itself,\n\nMake your declaration a definition and that\'ll be handled.  (Declarations and \ndefinitions look very similar for non-function types; the code given above is \nactually a definition if it is not within a struct/union type.)\n\n> (e) assign the address of the "volume_label" structure\n> to the "cms_ptr" pointer variable at an appropriate point in the code,\n> and\n\nstruct volume_label vl;\nstruct cms_label *cms_ptr;\n\n/* Load data into vl */\n/* Determine that the data is actually a cms_label */\ncms_ptr = (void *) &vl;\n\nOr, in your specific case, you should be able to do something like:\n\nstruct cms_label *cms_ptr = (void *) disk_specific->anchor->vlabel;\n\nSince you are already dealing with a "struct volume_label *", there\'s no need \nfor the address-of operator (&).\n\n> (f) make references to the members of the cms_label structure.\n\ncms_ptr->label_id; /* Or any other member. */\n\n> How do I do this?  (Man, I wish I knew C!)\n\nExamples above good?  Please let me know if I can provide further assistance.\n-- \nBoyd Stephen Smith Jr.           \t ,= ,-_-. =.\nbss@iguanasuicide.net            \t((_/)o o(\\_))\nICQ: 514984 YM/AIM: DaTwinkDaddy \t `-\'(. .)`-\'\nhttp://iguanasuicide.net/        \t     \\_/\n', 'subject': 'Re: C programming question'}