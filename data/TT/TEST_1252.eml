{'body': 'Hi David\r\n\r\ninteresting software architecture discussion... :)\r\n\r\nOn Apr 29, 2010, at 2:10 PM, David Giovannini wrote:\r\n\r\n>=20\r\n> On Apr 29, 2010, at 2:00 AM, Matthias Ringwald wrote:\r\n>=20\r\n>> On 29.04.2010, at 08:11, David Giovannini wrote:\r\n>>>>=20\r\n>>>> In BTnut, the first Bluetooth stack I was involved, we used =\r\nseparate threads for different Bluetooth layers and protocols, but in =\r\nthe end, the required thread synchronization was just creating =\r\nunnecessary problems. In my new Bluetooth stack called BTstack =\r\n(btstack.org), the Bluetooth daemon runs in a single thread which can =\r\nhandle any number of clients. So far this seems to be the right choice, =\r\nboth for portability and for implementation ease.\r\n>>>=20\r\n>>> Yes, I want that single dedicated thread for BT. Forcing the client =\r\nof the BT library to share the same thread as BT service is the problem.\r\n>>>=20\r\n>>=20\r\n>> I would argue that this depends on the "contract" you provide for =\r\nyour library (also, I did not know you have to provide one in the first =\r\nplace).=20\r\n>=20\r\n> Every library has implicit and explicit contracts. Forcing a threading =\r\nmodel that eliminates the possibility to wait on a response is a =\r\ncontract that reduces usefulness (and could dramatically increase client =\r\ncode).\r\n\r\nYup. I do agree here, however, e.g., the Cocoa(Touch) Framework already =\r\nrequires "no blocking, all user interface operation on the main thread". =\r\nIf Apple then says: "all your Bluetooth communication has to be on the =\r\nmain thread, too", it does not restrict the rules set up by the Cocoa =\r\nFramework any further. So, if rules for apps are already set by the OS, =\r\nyour library would not restrict anything by saying it must be started =\r\nfrom the main loop and the main loop cannot block.\r\n\r\n>>=20\r\n>> E.g., BTstack uses unix domain sockets to handle communication =\r\nbetween the clients and the single Bluetooth daemon. To support the =\r\ndomain socket,=20\r\n>> the Cocoa(Touch) implementation registers a CFSocket that is wrapped =\r\ninto a CFRunLoopSource and added to the main run loop. So although it is =\r\na library, the communication with the server is on the main thread - not =\r\nthat it would matter for socket communication, but it fits nicely with =\r\nthe pure select()-based runloop for non-GUI applications. The WiiMote =\r\nOpenGL ES Demo (http://www.youtube.com/watch?v=3D3FPHpMonoC8) is =\r\nsingle-threaded without extra tricks.\r\n>=20\r\n> Would it be possible to register the CFRunLoopSource into another =\r\nthread\'s runloop?\r\nAre you asking about BTstack? If yes: the BTstack client  library does =\r\nnot provide a way to choose a run loop, but as it is only using =\r\nthread-safe socket functions, that could run on any given thread. If =\r\nthere is a clear need for such a feature, I would\'t mind adding a "set =\r\ndefault runloop" function. Would that help you in any way?\r\n\r\nBest=20\r\nMatthias=20=\r\n _______________________________________________\r\nDo not post admin requests to the list. They will be ignored.\r\nBluetooth-dev mailing list      (Bluetooth-dev@lists.apple.com)\r\nHelp/Unsubscribe/Update your Subscription:\r\nhttp://lists.apple.com/mailman/options/bluetooth-dev/mlsubscriber.tech%40csmining.org\r\n\r\nThis email sent to mlsubscriber.tech@csmining.org\r\n\r\n', 'subject': 'Re: Bluetooth-dev Digest, Vol 7, Issue 13'}