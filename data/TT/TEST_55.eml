{'body': 'Hi,\r\n\r\nI\'ve written a JNI OpenGL program, but the native OpenGL window isn\'t\r\nbeing shown. I am new to cocoa and Apple windowing development and\r\ndon\'t understand why the window isn\'t shown even though the print\r\nstatements in the OpenGL drawing code are all executed. Below is a\r\nsection of code in C and java that should create and display the\r\nwindow then draw a simple OpenGL object.\r\n\r\nDavid\r\n\r\n\r\n// object-C code\r\nint InitWindowMac(JNIEnv * env, jobject panel)\r\n{\t\r\n\tstd::cout << "Enteringing InitWindowMac" << std::endl;\r\n\r\n\tjboolean result = JNI_FALSE;\r\n\tjint lock = 0;\r\n\r\n\tstd::cout << "Before result = JAWT_GetAWT(env, &awt);" << std::endl;\r\n   \t\r\n\t// get the AWT\r\n    awt.version = JAWT_VERSION_1_4;\r\n\t\r\n\tresult = JAWT_GetAWT(env, &awt);\r\n\t\r\n\tif(result != JNI_FALSE)\r\n\t\tstd::cout << "JNI_FALSE" << std::endl;\r\n\r\n\tstd::cout << "After result = JAWT_GetAWT(env, &awt);" << std::endl;\r\n\r\n\tif( env->ExceptionOccurred() )\r\n\t{\r\n\t\tenv->ExceptionDescribe();\r\n\t}\r\n\tassert(result != JNI_FALSE);\r\n\t\r\n\tstd::cout << "After JAWT_GetAWT assert" << std::endl;\r\n\r\n\tds = awt.GetDrawingSurface(env, panel);\r\n\t\r\n\tstd::cout << "After ds = awt.GetDrawingSurface(env, panel);" << std::endl;\r\n\t\r\n\tif( env->ExceptionOccurred() )\r\n\t{\r\n\t\tenv->ExceptionDescribe();\r\n\t}\r\n\tassert(ds != NULL);\r\n\t\r\n\tstd::cout << "After awt.GetDrawingSurface(env, panel) assert" << std::endl;\r\n\r\n\r\n\tlock = ds->Lock(ds);\t\r\n\tif( env->ExceptionOccurred() )\r\n\t{\r\n\t\tenv->ExceptionDescribe();\r\n\t}\r\n\tassert( (lock & JAWT_LOCK_ERROR) == 0 );\r\n\t\r\n\tstd::cout << "After awt.GetDrawingSurface(env, panel) assert" << std::endl;\r\n\r\n\tdsi = ds->GetDrawingSurfaceInfo(ds);\r\n\tif(dsi)\r\n\t{\r\n\t\tdsi_mac = (JAWT_MacOSXDrawingSurfaceInfo*)dsi->platformInfo;\r\n\t\tif( env->ExceptionOccurred() )\r\n\t\t{\r\n\t\t\tenv->ExceptionDescribe();\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << "dsi is null exiting" << std::endl;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tstd::cout << "Before NSView *view = dsi_mac->cocoaViewRef;" << std::endl;\r\n\t\r\n\t// get the corresponding peer from the calling panel\r\n\tNSView *view = dsi_mac->cocoaViewRef;\r\n\r\n\tstd::cout << "Before NSView NSWindow *window = [view Window];" << std::endl;\r\n\t\r\n\tif(view)\r\n\t\tstd::cout << "view !=null" << std::endl;\r\n\telse\r\n\t{\r\n\t\tstd::cout << "view is null exiting" << std::endl;\r\n\t\treturn 0;\r\n\t}\r\n\t\t\r\n\t// get the coregraphics from the parent window\r\n\tNSWindow *window = [view window];\r\n\t\r\n\tstd::cout << "Before NSOpenGLPixelFormatAttribute attrs[]" << std::endl;\r\n\r\n\tNSOpenGLPixelFormatAttribute attrs[] = {\r\n\r\n\t\tNSOpenGLPFAScreenMask,\r\n\r\n\t\tCGDisplayIDToOpenGLDisplayMask(kCGDirectMainDisplay),\r\n\r\n\t\tNSOpenGLPFAColorSize, 24,\r\n\r\n\t\tNSOpenGLPFADepthSize, 16,\r\n\r\n\t\tNSOpenGLPFADoubleBuffer,\r\n\r\n\t\tNSOpenGLPFAAccelerated,\r\n\r\n\t\t0\r\n\r\n\t};\r\n\r\n\tNSOpenGLPixelFormat *pixelFormat;\r\n\t\r\n\tstd::cout << "Before pixelFormat = [[NSOpenGLPixelFormat alloc]\r\ninitWithAttributes:attrs];" << std::endl;\r\n\t\t\r\n\tpixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];\r\n\t\r\n\t\r\n\tcp = new GraphicsContextProperties();\r\n\tstd::cout << "after cp = new GraphicsContextProperties();" << std::endl;\r\n\tcp->context = NULL;\r\n\tcp->str = "";\r\n\r\n\tcontext = [NSOpenGLContext alloc];\r\n\t\r\n\tif ( context )\r\n\t{\r\n\t\tstd::cout << "context != null" << std::endl;\r\n\t\t\r\n\t\t// Set the current OpenGL context\t\t\r\n\t\t[context makeCurrentContext];\r\n\r\n\t\tstd::cout << "after [context makeCurrentContext];" << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << "context == null exiting" << std::endl;\r\n\t\texit(0);\r\n\t}\r\n\t\t\r\n\tcp->context = context;\r\n\t\r\n\t// match java\t\t\r\n\tNSRect windowRect = [window frame];\r\n\tCGAffineTransform xform = CGAffineTransformMake(1, 0, 0, -1,\r\ndsi->bounds.x, windowRect.size.height-dsi->bounds.y);\r\n\tCGContextConcatCTM( (CGContext*)context, xform );\r\n\r\n\tif(cp)\r\n\t\tBuildLinkList(env, panel, cp);\r\n\telse\r\n\t{\r\n\t\tstd::cout << "cp == null exiting" << std::endl;\r\n\t\texit(0);\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\n\r\n// get native window that corresponds to the current java window\r\nJNIEXPORT jboolean JNICALL Java_AvistoGL_setForDrawing(JNIEnv * env,\r\njobject panel)\r\n{\r\n\tjclass cls = env->GetObjectClass(panel);\r\n\tjmethodID method = env->GetMethodID(cls, "getName", "()Ljava/lang/String;");\r\n\tjstring name = (jstring) env->CallObjectMethod(panel,method);\r\n\tconst char * chr = env->GetStringUTFChars(name, 0);\r\n\r\n\tstd::string str = chr;\r\n        cp = contextList->retrieve_item(str);\r\n\r\n\t\tif( !cp )\r\n\t\t{\r\n\t\t\tstd::cout << "graphics context is not in the graphics context\r\nlist"<< std::endl;\r\n\t\t\treturn false;\r\n\t\t}\r\n                int ret = GetCurrentContext();\r\n\t\treturn ret;\r\n\r\n}\r\n\r\n\r\n// java code\r\n\r\n\tpublic void gl_draw()\r\n\t{\r\n\t\t\r\n\t\t// ensure that the OpenGL is correctly initialized\r\n\t\tif(isInitalized == false)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tmakeOpenGLWindow(1);\r\n\t\t\t}\r\n\t\t\tcatch(Exception e)\r\n\t\t\t{\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tgl_init();\r\n\t\t\tisInitalized = true;\r\n\t\t}\t\t\t\r\n\t\t\r\n\t\t// find the correct panel to draw the OpenGL into.\r\n\t\tsetForDrawing();\t\t\r\n\t\t\r\n\t\tSystem.out.println("gl_draw()");\r\n\t\tif(!picking)\r\n\t\t{\r\n\t\t\treSizeGLScene( getWidth(), getHeight() );\r\n\t\t\tSystem.out.println("!picking");\r\n\t\t}\r\n\t\t\r\n \t\t//draw\r\n\t\tglClearColor(backgroundColour[0], backgroundColour[1],\r\nbackgroundColour[2], backgroundColour[3]);\r\n\r\n\t\tSystem.out.println("After glClearColor");\r\n\r\n \t \tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n\t\tSystem.out.println("After glClear");\r\n \t \tglMatrixMode(GL_MODELVIEW);\r\n\t\tSystem.out.println("After glMatrixMode");\r\n \t \tglLoadIdentity();\r\n\t\tSystem.out.println("After glLoadIdentity");\r\n\r\n \t \tgluLookAt(eye_x, eye_y, eye_z, lookatX, lookatY, lookatZ, upX, upY, upZ);\r\n\t\tSystem.out.println("After gluLookAt");\r\n\r\n\t\tglDisable(GL_LIGHTING);\r\n\t\tglDisable(GL_LIGHT0);\r\n\r\n\t\tSystem.out.println("After glDisable");\r\n\t\t\r\n\t\tglEnable(GL_CULL_FACE);\r\n\t\tglCullFace(GL_BACK);\r\n\t\t\t\t\r\n\t\tglTranslatef(0.0f, 0.0f, 5.0f);\r\n\r\n\t\tSystem.out.println("After glTranslate");\r\n\r\n \t \t// 3rd blue\r\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\r\n\t\tglPushName(21);\r\n\t\t\tSystem.out.println("After glPushName");\r\n\t\t\tglPushMatrix();\r\n\t\t\t\tglTranslatef(1.3f, 0f, 10.0f);\r\n\t\t\t\tSystem.out.println("After glTranslate");\r\n\t\t\t\tglBegin(GL_TRIANGLES);\r\n\t\t\t\t\tglVertex3f(0.0f, 0.0f, 0.0f);\r\n\t\t\t\t\tglVertex3f(2.0f, 0.0f, 0.0f);\r\n\t\t\t\t\tglVertex3f(1.0f, 2.0f, 0.0f);\r\n\t\t\t\tglEnd();\r\n\t\t\tglPopMatrix();\r\n\t\tglPopName();\r\n\r\n\t\tSystem.out.println("After blue");\r\n\t \t\t\t\r\n\t\tglDisable(GL_CULL_FACE);\r\n\t\tglEnable(GL_LIGHTING);\r\n\t\tglEnable(GL_LIGHT0);\r\n\r\n\t\tSystem.out.println("Before glFlush()");\r\n\r\n \t \tglFlush();\r\n\t\tSystem.out.println("After glFlush()");\r\n \t    swapBuffers();\t\t\r\n\t\tSystem.out.println("After swapBuffers()");\r\n\t}\r\n _______________________________________________\r\nDo not post admin requests to the list. They will be ignored.\r\nJava-dev mailing list      (Java-dev@lists.apple.com)\r\nHelp/Unsubscribe/Update your Subscription:\r\nhttp://lists.apple.com/mailman/options/java-dev/mlsubscriber.tech%40csmining.org\r\n\r\nThis email sent to mlsubscriber.tech@csmining.org\r\n\r\n', 'subject': 'Native window not shown in JNI'}