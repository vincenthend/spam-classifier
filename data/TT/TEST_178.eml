{'body': 'No, you need to learn how declarations work in C.  You have specified\ntestbuff as "an array of 1024 pointers to characters".  That means,\nyou have allocated an array big enough to store 1024 pointers.  On\nmost machines, that\'s 4 bytes per pointer, which indeed would give you\n4096.\n\nJohn\n\nOn Fri, Nov 22, 2002 at 10:27:53PM +0500, Ali Saifullah Khan wrote:\n> Here is a test done on the return of sizes by sizeof() using pointers.\n> \n> #include <iostream.h>\n> \n> int main(void) {\n>  char *testbuff[1024];\n> \n>  int len = sizeof(testbuff);\n>  cout << len << "\\n";\n>  return 0;\n> }\n> \n> c:>debug\\testbuff\n> 4096\n> \n> The output from this is 4096 but infact it should be returning 1024.\n> Apparently, using a pointer has multiplied the value of the original size of\n> the testbuff[] buffer by the size of the " pointer " ?\n> \n> char pointers have a size of 4 bytes.....as is shown when output is 4 bytes\n> using " int len = sizeof((char*)testbuff); "\n> \n> c:>debug\\testbuff\n> 4\n> \n> so sizeof is returning the size of the "first" entity passed to it, that\n> being the size of the pointer. " * "\n> \n> Whats confusing is when sizeof outputs the value for something like " char *\n> testbuff[] "\n> Here the macro seems to be multiplying the sizes of entities passed to it,\n> by considering the first entity as the pointer denoted by the asterisk\n> itself " * ", and then taking this value of 4 and multiplying it with the\n> size of the buffer testbuff[] which is 1024, to produce an output of 4096.\n> \n> Rather strange behaviour. ???\n> ----- Original Message -----\n> From: <cdavison@nucleus.com>\n> To: <secprog@securityfocus.com>\n> Cc: <viega@securesoftware.com>\n> Sent: Tuesday, November 19, 2002 2:59 AM\n> Subject: Re: Are bad developer libraries the problem with M$ software?\n> \n> \n> > ----- Original Message -----\n> > From: John Viega\n> > Sent: 11/18/2002 2:28:08 PM\n> > To: cdavison@nucleus.com\n> > Cc: secprog@securityfocus.com\n> > Subject: Re: Are bad developer libraries the problem with M$ software?\n> >\n> > > strlen does not work, because he was trying to get at the ALLOCATED\n> > > size of a buffer, not the actual size of the buffer.\n> >\n> > You\'re right. I was looking at the safe_strncpy code, and it looks like\n> the author did use strlen.\n> >\n> > > sizeof will return the size of the data type passed to it.  So if you\n> > > declared mystr as char mystr[1024];, it will return as the original\n> > > author wanted.\n> >\n> > It will not work with a char*, so if your strings are dynamically\n> allocated, or passed to you as a pointer, these macros will not work.\n> >\n> >\n> >\n> >\n\n\n', 'subject': 'Re: Are bad developer libraries the problem with M$ software?'}